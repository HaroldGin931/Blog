# 理解 Sum-Check
感谢: Tianyu, Charles, 0xhhh

本文假设读者对 SNARK 具有一定的认知, 本文在内容组织上采用可小单元的形式, 即不同的 Takeaway
读者在不需要了解更多细节的情况下

## 引言: SumCheck 的重要性
 

## TakeAway 1 - SumCheck 保障了什么的正确性?

Prover 承诺它进行了**某种计算过程**得到了一个值 H, 这时他希望说服 Verifier 这个 H 确实是通过执行此**计算过程**算出的结果, 而不是随便编造的数值, 并且 Verifier 不需要重新算一遍来进行验证 (注意这里是外包计算的场景, 我们先不讨论零知识的事情)

这个结果H是由下述计算过程得出的:

$H:=\sum_{b_1\in\{0,1\}}\sum_{b_2\in\{0,1\}}\ldots\sum_{b_\nu\in\{0,1\}}g(b_1,\ldots,b_\nu)$

TakeAway: SumCheck 保障的是 Verifer 可以相信 Prover 确实执行了上面的计算过程(亦即得到了真实的计算结果 H)

我会在下面的章节中解释这个公式和 SumCheck 的流程

## TakeAway - SumCheck 协议是如何工作的?
```mermaid
graph TD;
 H["$$x^2$$"] -->B;
 A-->C; 
 B-->D;
 C-->D;
 ```

### 上面这个算式是什么?

为了帮助大家理解, 请容许我稍显啰嗦的解释这个公式, 首先我们 先看一个小一点的算式

····

让我们来给上一个的 TakeAway 增加一点细节: “SumCheck 保障的是 Verifer 可以相信 Prover 确实对hypercube上的每一个点进行了运算, 其中 P 进行了 2^v次计算, 并实现让 V 以更小的计算代价来验证P的计算结果H” 接下来让我们看一下 SumCheck 的流程, 以及它如何实现让 V 以更小的计算代价来验证H的正确性

### Sumcheck 的流程

在给出 sumcheck 的具体流程之前, 我们先一起进行如下的思考

在面对


如果我们把 Sum 拆开 会发现这里有一个递归的结构

第一轮我们检查 H 是否正确

	H == g(0, b2, b3 ...) + g(1, b2, b3 ...) b2 - bn

第二轮我们检察上一轮信任的 g(0, b2, b3 ...), g(1, b2, b3 ...) 是否正确
	
	g(0, b2, b3 ...) == g(0, 0, b3 ...) + g(0, 1, b3 ...) b3 - bn
	
	g(1, b2, b3 ...) == g(1, 0, b3 ...) + g(1, 1, b3 ...) b3 -bn

第三轮我们检察上一轮信任的 g(0, 0, b3 ...), g(0, 1, b3 ...), g(1, 0, b3 ...), g(1, 1, b3 ...) 是否正确

	g(0, 0, b3 ...) == g(0, 0, 0 ...) + g(0, 0, 1 ...) b4 -n
	
	g(0, 1, b3 ...) == g(0, 1, 0 ...) + g(0, 1, 1 ...) b4 -
	
	g(1, 0, b3 ...) == g(1, 0, 0 ...) + g(1, 0, 1 ...)
	
	g(1, 1, b3 ...) == g(1, 1, 0 ...) + g(1, 1, 1 ...)

以此类推, 虽然我们找到了一个递归的结构, 可是计算量缺丝毫不减. 因为我们每次为了验证等号左侧的值, 我们需要向 Prover 索要两个新的数字进行计算, 并且在下一轮中验证这两个新的数字是否可信. 不过我们去看每一轮中的一个式子, 我们会发现, 每一轮 Verifier 依赖 Prover 计算的 Sum 是逐步减少的.

那我们能否保留这种减少的特性, 并每一轮验证更少的式子呢? 这其实是可以做到的

让我们仔细看一下, 等号右侧的两个值其实是同一个单项式 g(X) 在0, 1上计算后的结果 g(0) g(1), 
那如果 Verifier 改成
1. 每次从 Prover 索要单项式 g(X), Verifier 自己计算 g(0) g(1), 然后为了保证多项式的正确性,
2. Verifier 生成一个随机数 r, 并让 Prover 根据 r 计算一个承诺, 这个承诺是 g(r, b2, b3, ...)

这时我们发现 我们的问题从原来验证H, 即验证” g() 在2^v个点上的总和“ 变为验证 g(r, ) 在 2^(v-1)上个点的总和

这样, 我们每一轮就变成了: 信任一个多项式, 并用这个多项式验证上一轮信任的数字 
1. 获取多项式 g(X1, ) 与承诺 g(r1), 并验证 H = g(0) + g(1), 
2. 获取多项式 g(r1, X2) 与承诺 g(r1, r2), 并验证 g(r1) = g(r1, 0) + g(r1, 1)
3. 获取多项式 g(r1, r2, X3) 与承诺g(r1, r2, r3), 并验证 g(r1, r2) = g(r1, r2, 0) + g(r1, r2, 1),

而这就是 SumCheck 的核心流程, 让我们引用 Justin Thaler 的讲义, 原文如下


## TakeAway - SumCheck 如何实现零知识

## Reference
[Justin Thaler - Deep Dive into the Sumcheck Protocol | Ingonyama Sessions](https://www.youtube.com/watch?v=uFhppTJfjiY)
